const data = 
[
    {
      "S.NO": 1,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which of the following is not a disadvantage to the usage of array?",
      "OPTION  A": "Fixed size",
      "OPTION  B": "There are chances of wastage of memory space if elements inserted in an array are lesser than the allocated size",
      "OPTION  C": "Insertion based on position",
      "OPTION  D": "Accessing elements at specified positions",
      "CORRECT ANSWER": "D"
    },
    {
      "S.NO": 2,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which operation is most efficient in a linked list compared to an array?",
      "OPTION  A": "Random access to elements.",
      "OPTION  B": "Insertion at the beginning.",
      "OPTION  C": "Insertion at the end.",
      "OPTION  D": "Sorting.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 3,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which data structure is used internally to manage memory for dynamic linked list nodes?",
      "OPTION  A": "Stack",
      "OPTION  B": "Heap",
      "OPTION  C": "Queue",
      "OPTION  D": "Array",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 4,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What data structure would you use to implement undo functionality using a linked list?",
      "OPTION  A": "Queue",
      "OPTION  B": "Stack",
      "OPTION  C": "Circular linked list",
      "OPTION  D": "Doubly linked list",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 5,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which of these is not an application of a linked list?",
      "OPTION  A": "To implement file systems",
      "OPTION  B": "For separate chaining in hash-tables",
      "OPTION  C": "To implement non-binary trees",
      "OPTION  D": "Random Access of elements",
      "CORRECT ANSWER": "D"
    },
    {
      "S.NO": 6,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "A linear collection of data elements where the linear node is given by means of pointer is called?",
      "OPTION  A": "Linked list",
      "OPTION  B": "Node list",
      "OPTION  C": "Primitive list",
      "OPTION  D": "Unordered list",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 7,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the effect of memory fragmentation on linked list operations?",
      "OPTION  A": "It improves the performance of linked list operations.",
      "OPTION  B": "It has no effect on linked list operations.",
      "OPTION  C": "It can degrade the performance of linked list operations due to scattered memory allocation.",
      "OPTION  D": "It prevents linked list operations from completing.",
      "CORRECT ANSWER": "C"
    },
    {
      "S.NO": 8,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the correct way to free memory of all nodes in a linked list?",
      "OPTION  A": "Traverse the list and use free() on each node.",
      "OPTION  B": "Use free() only on the head node.",
      "OPTION  C": "Assign NULL to each node.",
      "OPTION  D": "Memory is automatically freed when the program ends.",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 9,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "In a doubly linked list, how do you check if a node is the head node?",
      "OPTION  A": "The node’s next pointer is NULL.",
      "OPTION  B": "The node’s previous pointer is NULL.",
      "OPTION  C": "The node’s data is 0.",
      "OPTION  D": "The node’s previous pointer is the node itself.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 10,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the primary difference between a singly linked list and a doubly linked list?",
      "OPTION  A": "Singly linked lists have head and tail nodes; doubly linked lists do not.",
      "OPTION  B": "Singly linked lists can only be traversed in one direction; doubly linked lists can be traversed in both directions.",
      "OPTION  C": "Singly linked lists use more memory per node than doubly linked lists.",
      "OPTION  D": "Singly linked lists have circular references; doubly linked lists do not.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 11,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the correct way to insert a node before a given node in a singly linked list?",
      "OPTION  A": "Find the node’s previous node and update its next pointer.",
      "OPTION  B": "Update the next pointer of the given node to point to the new node.",
      "OPTION  C": "Insert the node at the beginning and adjust the head pointer.",
      "OPTION  D": "It’s not possible to insert before a given node.",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 12,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "The concatenation of two lists can be performed in O(1) time. Which of the following variation of the linked list can be used?",
      "OPTION  A": "Singly linked list",
      "OPTION  B": "Doubly linked list",
      "OPTION  C": "Circular doubly linked list",
      "OPTION  D": "Array implementation of list",
      "CORRECT ANSWER": "C"
    },
    {
      "S.NO": 13,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which algorithm is typically used to reverse a linked list?",
      "OPTION  A": "Merge Sort",
      "OPTION  B": "Insertion Sort",
      "OPTION  C": "Recursive traversal",
      "OPTION  D": "Iterative pointer manipulation",
      "CORRECT ANSWER": "D"
    },
    {
      "S.NO": 14,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What will be the result of attempting to delete the head node of a singly linked list?",
      "OPTION  A": "The list becomes empty.",
      "OPTION  B": "The next node becomes the new head.",
      "OPTION  C": "The previous node becomes the new head.",
      "OPTION  D": "The operation fails.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 15,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "You are given pointers to first and last nodes of a singly linked list, which of the following operations are dependent on the length of the linked list?",
      "OPTION  A": "Delete the first element",
      "OPTION  B": "Insert a new element as a first element",
      "OPTION  C": "Delete the last element of the list",
      "OPTION  D": "Add a new element at the end of the list",
      "CORRECT ANSWER": "C"
    },
    {
      "S.NO": 16,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How do you find the middle node of a singly linked list?",
      "OPTION  A": "Traverse the list and count the nodes, then access the node at half the count.",
      "OPTION  B": "Use two pointers, one moving one step at a time and the other two steps.",
      "OPTION  C": "Use a recursive approach to find the middle.",
      "OPTION  D": "Compare data values of nodes to find the median.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 17,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the significance of the free() function in managing linked list nodes?",
      "OPTION  A": "It allocates memory for new nodes.",
      "OPTION  B": "It initializes nodes to zero.",
      "OPTION  C": "It deallocates memory of nodes.",
      "OPTION  D": "It searches for nodes in the list.",
      "CORRECT ANSWER": "C"
    },
    {
      "S.NO": 18,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is a memory efficient double linked list?",
      "OPTION  A": "Each node has only one pointer to traverse the list back and forth",
      "OPTION  B": "The list has breakpoints for faster traversal",
      "OPTION  C": "An auxiliary singly linked list acts as a helper list to traverse through the doubly linked list",
      "OPTION  D": " A doubly linked list that uses bitwise AND operator for storing addresses",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 19,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How do you calculate the pointer difference in a memory efficient double linked list?",
      "OPTION  A": "head xor tail",
      "OPTION  B": "pointer to previous node xor pointer to next node",
      "OPTION  C": "pointer to previous node – pointer to next node",
      "OPTION  D": "pointer to next node – pointer to previous node",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 20,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What happens if you mistakenly free a node twice in a linked list?",
      "OPTION  A": "The program continues to run normally.",
      "OPTION  B": "It causes undefined behavior, potentially leading to a crash.",
      "OPTION  C": "The node’s memory is reallocated.",
      "OPTION  D": "The node is reinserted into the list.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 21,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What differentiates a circular linked list from a normal linked list?",
      "OPTION  A": "You cannot have the ‘next’ pointer point to null in a circular linked list",
      "OPTION  B": "It is faster to traverse the circular linked list",
      "OPTION  C": "In a circular linked list, each node points to the previous node instead of the next node",
      "OPTION  D": "Head node is known in circular linked list",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 22,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which of the following is true for the malloc() function used to allocate memory for a linked list node in C?",
      "OPTION  A": "malloc() initializes allocated memory to zero.",
      "OPTION  B": "malloc() allocates memory but does not initialize it.",
      "OPTION  C": "malloc() returns the number of bytes allocated.",
      "OPTION  D": "malloc() cannot be used with linked lists.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 23,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How do you reverse a singly linked list?",
      "OPTION  A": "Change the head to point to the last node.",
      "OPTION  B": "Use recursion to reverse the pointers of all nodes.",
      "OPTION  C": "Change the direction of the next pointers of all nodes.",
      "OPTION  D": "Swap the data of each node with its next node.",
      "CORRECT ANSWER": "C"
    },
    {
      "S.NO": 24,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How do you represent a node in a singly linked list in C?",
      "OPTION  A": "struct Node { int data; struct Node* next; };",
      "OPTION  B": "struct Node { int data; struct Node* prev; };",
      "OPTION  C": "struct Node { int data; struct Node* next; struct Node* prev; };",
      "OPTION  D": "struct Node { int data; int next; };",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 25,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which of the following is false about a doubly linked list?",
      "OPTION  A": "We can navigate in both the directions",
      "OPTION  B": "It requires more space than a singly linked list",
      "OPTION  C": "The insertion and deletion of a node take a bit longer",
      "OPTION  D": "Implementing a doubly linked list is easier than singly linked list",
      "CORRECT ANSWER": "D"
    },
    {
      "S.NO": 26,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is a memory efficient double linked list?",
      "OPTION  A": "Each node has only one pointer to traverse the list back and forth",
      "OPTION  B": "The list has breakpoints for faster traversal",
      "OPTION  C": "An auxiliary singly linked list acts as a helper list to traverse through the doubly linked list",
      "OPTION  D": "A doubly linked list that uses bitwise AND operator for storing addresses",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 27,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How do you calculate the pointer difference in a memory efficient double linked list?",
      "OPTION  A": "head xor tail",
      "OPTION  B": "pointer to previous node xor pointer to next node",
      "OPTION  C": "pointer to previous node – pointer to next node",
      "OPTION  D": "pointer to next node – pointer to previous node",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 28,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which of the following is false about a doubly linked list?",
      "OPTION  A": "We can navigate in both the directions",
      "OPTION  B": "It requires more space than a singly linked list",
      "OPTION  C": "The insertion and deletion of a node take a bit longer",
      "OPTION  D": "Implementing a doubly linked list is easier than singly linked list",
      "CORRECT ANSWER": "D"
    },
    {
      "S.NO": 29,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the significance of the free() function in managing linked list nodes?",
      "OPTION  A": "It allocates memory for new nodes.",
      "OPTION  B": "It initializes nodes to zero.",
      "OPTION  C": "It deallocates memory of nodes.",
      "OPTION  D": "It searches for nodes in the list.",
      "CORRECT ANSWER": "C"
    },
    {
      "S.NO": 30,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What happens to the next pointer of the last node in a singly linked list?",
      "OPTION  A": "Points to the first node.",
      "OPTION  B": "Points to itself.",
      "OPTION  C": "Is set to NULL.",
      "OPTION  D": "Points to a sentinel node.",
      "CORRECT ANSWER": "C"
    },
    {
      "S.NO": 31,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How do you optimize memory usage when handling linked lists of large structures?",
      "OPTION  A": "Use arrays instead of linked lists.",
      "OPTION  B": "Use pointers to store large data separately.",
      "OPTION  C": "Store all data in a single node.",
      "OPTION  D": "Allocate all nodes at once.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 32,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Linked list refers to",
      "OPTION  A": "A collection of elements, each pointing to the next.",
      "OPTION  B": "A sequentially stored list of elements.",
      "OPTION  C": "A list where elements are stored at contiguous memory locations.",
      "OPTION  D": "A list that uses a fixed size array.",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 33,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "In a linked list, what is the main disadvantage of inserting an element at the end of the list?",
      "OPTION  A": "It always takes O(1) time.",
      "OPTION  B": "It requires traversing the entire list to reach the end.",
      "OPTION  C": "It increases the list’s length.",
      "OPTION  D": "It decreases the list’s length.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 34,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which algorithm is typically used to reverse a linked list?",
      "OPTION  A": "Merge Sort",
      "OPTION  B": "Insertion Sort",
      "OPTION  C": "Recursive traversal",
      "OPTION  D": "Iterative pointer manipulation",
      "CORRECT ANSWER": "D"
    },
    {
      "S.NO": 35,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is a sentinel node in a linked list?",
      "OPTION  A": "A node used to store data temporarily.",
      "OPTION  B": "A node that does not store any data but indicates the end of the list.",
      "OPTION  C": "The head node of the list.",
      "OPTION  D": "A node that connects the list to another list.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 36,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which operation is most efficient in a linked list compared to an array?",
      "OPTION  A": "Random access to elements.",
      "OPTION  B": "Insertion at the beginning.",
      "OPTION  C": "Insertion at the end.",
      "OPTION  D": "Sorting.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 37,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How do you check if a singly linked list is empty?",
      "OPTION  A": "Check if the head pointer is NULL.",
      "OPTION  B": "Check if the tail pointer is NULL.",
      "OPTION  C": "Check if the last node’s next pointer is NULL.",
      "OPTION  D": "Traverse the list to see if it contains any nodes.",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 38,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which condition indicates a loop in a linked list?",
      "OPTION  A": "A node's next pointer is NULL.",
      "OPTION  B": "A node's next pointer points back to a previous node.",
      "OPTION  C": "A node's next pointer points to itself",
      "OPTION  D": "A node's data is zero",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 39,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How can you insert a new node at the beginning of a singly linked list in C?",
      "OPTION  A": "Modify the last node’s next pointer.",
      "OPTION  B": "Update the head to point to the new node, and the new node’s next pointer to the old head.",
      "OPTION  C": "Traverse to the end and update the last node’s next pointer.",
      "OPTION  D": "It’s not possible.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 40,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How do you insert a new node in a doubly linked list after a given node?",
      "OPTION  A": "Update the next pointer of the given node and the previous pointer of the new node.",
      "OPTION  B": "Update the next pointer of the new node and the previous pointer of the given node.",
      "OPTION  C": "Update the previous pointer of the given node and the next pointer of the new node.",
      "OPTION  D": "It’s not possible to insert after a given node.",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 41,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What happens if you mistakenly free a node twice in a linked list?",
      "OPTION  A": "The program continues to run normally.",
      "OPTION  B": "It causes undefined behavior, potentially leading to a crash.",
      "OPTION  C": "The node’s memory is reallocated.",
      "OPTION  D": "The node is reinserted into the list.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 42,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the best method to copy a linked list into another linked list?",
      "OPTION  A": "Traverse the original list and create new nodes for the new list.",
      "OPTION  B": "Use the memcpy() function.",
      "OPTION  C": "Assign the head of the original list to the head of the new list.",
      "OPTION  D": "Copy node addresses directly.",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 43,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "Which of the following statements is true about a doubly linked list?",
      "OPTION  A": "Each node contains data and a single pointer.",
      "OPTION  B": "Each node contains data and two pointers.",
      "OPTION  C": "Each node contains data, two pointers, and a third pointer to the middle node.",
      "OPTION  D": "Each node can only point to the next node.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 44,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "In a linked list, what is the impact of having multiple references (pointers) to the same node?",
      "OPTION  A": "Causes data redundancy.",
      "OPTION  B": "May lead to data inconsistency if the node is modified.",
      "OPTION  C": "Ensures that node deletion is easier.",
      "OPTION  D": "Improves the list's traversal efficiency.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 45,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the correct method to delete the tail node in a singly linked list?",
      "OPTION  A": "Update the second-to-last node’s next pointer to NULL.",
      "OPTION  B": "Update the last node’s next pointer to the head.",
      "OPTION  C": "Traverse the list and free the last node.",
      "OPTION  D": "Reassign the last node’s pointer to the second node",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 46,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How can you detect a node’s presence in a doubly linked list?",
      "OPTION  A": "Traverse from head to tail and compare each node.",
      "OPTION  B": "Use a hash table to store node addresses.",
      "OPTION  C": "Use the head node’s previous pointer.",
      "OPTION  D": "Check the node’s data directly.",
      "CORRECT ANSWER": "A"
    },
    {
      "S.NO": 47,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the most efficient way to delete the last node in a doubly linked list?",
      "OPTION  A": "Update the tail’s previous pointer to NULL",
      "OPTION  B": "Traverse the list from the head to find the last node.",
      "OPTION  C": "Update the next pointer of the second-to-last node to NULL",
      "OPTION  D": "Update the head node to the new tail.",
      "CORRECT ANSWER": "C"
    },
    {
      "S.NO": 48,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What does the NULL pointer signify in a linked list?",
      "OPTION  A": "The list is empty.",
      "OPTION  B": "The end of the list.",
      "OPTION  C": "The start of the list.",
      "OPTION  D": "The list contains no data.",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 49,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "How would you represent a node in a doubly linked list in C?",
      "OPTION  A": "struct Node { int data; struct Node* next; };",
      "OPTION  B": "struct Node { int data; struct Node* prev; struct Node* next; };",
      "OPTION  C": "struct Node { int data; int next; int prev; };",
      "OPTION  D": "struct Node { int data; struct Node* prev; };",
      "CORRECT ANSWER": "B"
    },
    {
      "S.NO": 50,
      "TOPIC NAME ": "TECHNICAL",
      "SECTION NAME": "MODULE  5",
      "QUESTION TEXT": "What is the main advantage of a doubly linked list over a singly linked list?",
      "OPTION  A": "Easier random access to elements.",
      "OPTION  B": "Less memory usage.",
      "OPTION  C": "Easier insertion and deletion from both ends.",
      "OPTION  D": "Faster searching.",
      "CORRECT ANSWER": "C"
    }
  ]
  ;

let currentQuestionIndex = 0;

const questionNumberElement = document.getElementById('question-number');
const topicNameElement = document.getElementById('topic-name');
const questionTextElement = document.getElementById('question-text');
const optionAElement = document.getElementById('option-a');
const optionBElement = document.getElementById('option-b');
const optionCElement = document.getElementById('option-c');
const optionDElement = document.getElementById('option-d');
// const optionEElement = document.getElementById('option-e');
const showAnswerButton = document.getElementById('show-answer');
const nextQuestionButton = document.getElementById('next-question');

function loadQuestion(index) {
    const question = data[index];
    questionNumberElement.textContent = `Question ${index + 1}`;
    topicNameElement.textContent = question['TOPIC NAME '];
    questionTextElement.textContent = question['QUESTION TEXT'];
    optionAElement.textContent = question['OPTION  A'];
    optionBElement.textContent = question['OPTION  B'];
    optionCElement.textContent = question['OPTION  C'];
    optionDElement.textContent = question['OPTION  D'];
    // optionEElement.textContent = question['OPTION  E'];
    showAnswerButton.onclick = () => alert(`Correct answer: ${question['CORRECT ANSWER']}`);
}

nextQuestionButton.onclick = () => {
    currentQuestionIndex = (currentQuestionIndex + 1) % data.length;
    loadQuestion(currentQuestionIndex);
};

// Load the first question initially
loadQuestion(currentQuestionIndex);
